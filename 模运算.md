# 模运算和余数
在计算机中，模运算是一个很重要的运算方式。我们熟知的早期版本的JDK中，HashMap计算key位置，就是用的取模运算。

模运算在数学中记做 `mod`。

##计算
$a \bmod b$  就是计算 a 除以 b 的余数.
如果 $a \bmod b$ = 0，那我们就说a可以被b整除。

```
7 mod 12 = 7

5 mod 12 = 5

24 mod 12 = 0

```

上面是我们常见的正数求余的算法，那如果是负数求余呢
## 负数求余
其实不管是正数还是负数，我们都可以根据一个公式来计算余数。
$a \bmod b$ = $a - (\lfloor a/b \rfloor* b)$
公式中的这个符号叫做取下界(floor),就是代码中常用的floor函数,是向下取整的意思是。含义就是如果是一个小数，就取第一个比它小的整数。举例说明一下
* $\lfloor 2.3 \rfloor$ = 2
* $\lfloor -2.3 \rfloor$ = -3

```
7 mod 12 = 7 - (0 * 12) = 7
5 mod 12 = 5 - (0 * 12) = 5
23 mod 12 = 24 - (2 * 12) = 0
-5 mod 12 = -5 - (-1 * 12) = -5 + 12 = 7
```

## 同余
在上面的例子中我们看到 7 mod 12 和 -5 mod 12 的结果都是 7，那我们就可以说 7和-5在模为12的时候，同余。用数学公式表达出来就是 
$7\equiv -5 \pmod {m}$


## 补数
在我简单来理解就是如果两个正数  A + B = 模，那么久可以说A和B互为补数。
那么在这个模下， X-A 就等价于 X+B
[补数](https://zh.wikipedia.org/wiki/%E8%A1%A5%E6%95%B0)
### 补数特性
简单来说补数具有这么一个特性。
即在给定了模的计算系统中（也可以理解为数字的字节长度）。A-B 等价于 A+(B基于模的补数)。
根据这个特性，我们就可以把计算机中的减法，转换成加法


我们以8位的二进制数来距离说明，8位的二进制数的模就是 $2^8$ = 256
我们先写出一个减法比如说15 - 8 = 7，按照上面的说法这个应该等价于 15 + 248 = 263。
你可能会说 7 和263 怎么可能等价呢。
那是因为我们说他等价是有一个前提的，就是给定的模或者说给定的数字的字节长度的前提下，也就是说，如果一个计算结果超过了这个字节长度所能表示的最大值，或者说超出了模的范围，那么他的高位就会被舍弃。

我们用二进制来计算一下。
```
  0000 1111
+ 1111 1000
------------
 10000 0111
```
发现最终的计算结果的位数是9位，所以必须得舍弃一个最高位，那最终的结果就是 0000 0111，也就是7。