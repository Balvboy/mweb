[toc]

# 原码、补码和反码
原码、补码和反码是计算机中表示数字的几种方式，他们是为了达成不同的目的而被创建的。

>我们根据数字的大小通常会使用不同的位数(8,16,32)来表示数字。下面的示例的话如果没有特殊说明，都使用8位的二进制来表示。

## 原码

### 计算规则
原码是人脑最容易理解和计算的表示方式。
表示规则是，使用最高位作为符号位，1表示负数，0表示正数，剩余的n-1位表示数字。

```
1000 0001 = -1
0000 0001 = 1
1111 1111 = -127
0111 1111 = 127
```
### 表示范围
所以一个n位的原码二进制数表示的范围是 -($2^{n-1}$-1) 到 ($2^{n-1}$-1)
比如8位的范围是 -($2^{7}$-1) 到 ($2^{7}$-1) = -127 到 127
同理16和32位的也是这样。

### 存在的问题
#### 无法进行计算
原码存在的最大问题就是，计算机无法使用原码直接进行计算，就拿 1 + (-1) = 0 这个来说。在计算机中如果直接使用原码计算得到的结果是-2,和预期的结果并不一致。
```
  1000 0001 
+ 0000 0001 
------------
  1000 0010 = -2
```
#### +0和-0的问题
通过原码的表示规则，我们得到一个+0和一个-0,这个明显不符合数学常识
```
1000 0000 = -0
0000 0000 = +0
```

## 反码
反码的出现就是人们为了解决原码不能直接进行计算的问题的。

### 计算规则
原码转反码
* 正数的反码是其本身,(正数的反码和其原码相同)
* 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.


反码转原码
* 先看是不是负数，如果是负数除符号位外按位取反

```
正数
    0000 0001 = 1
负数
    1000 0001[原] = -1
    1111 1110[反] = -1
```
这时候我们再来计算 1 + (-1) 
```
  0000 0001[反] 
+ 1111 1110[反]
------------
  1111 1111[反] = 1000 0000[原] = -0
```
所以反码的出现就解决的原码不能参与计算的问题。
但是+0和-0的问题还是没有解决。

## 补码
补码就是上面的问题的解决方式。
### 计算规则
* 正数的补码还是其本身,(正数的反码和其原码相同)
* 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)