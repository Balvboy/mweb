[toc]

# 原码、补码和反码
原码、补码和反码是计算机中表示数字的几种方式，他们是为了达成不同的目的而被创建的。

>我们根据数字的大小通常会使用不同的位数(8,16,32)来表示数字。下面的示例的话如果没有特殊说明，都使用8位的二进制来表示。

## 原码
`True form`
### 计算规则
原码是人脑最容易理解和计算的表示方式。
表示规则是，使用最高位作为符号位，1表示负数，0表示正数，剩余的n-1位表示数字。

```
1000 0001 = -1
0000 0001 = 1
1111 1111 = -127
0111 1111 = 127
```
### 表示范围
所以一个n位的原码二进制数表示的范围是 -($2^{n-1}$-1) 到 ($2^{n-1}$-1)
比如8位的范围是 -($2^{7}$-1) 到 ($2^{7}$-1) = -127 到 127
同理16和32位的也是这样。

### 存在的问题
#### 无法进行计算
原码存在的最大问题就是，计算机无法使用原码直接进行计算，就拿 1 + (-1) = 0 这个来说。在计算机中如果直接使用原码计算得到的结果是-2,和预期的结果并不一致。
```
  1000 0001 
+ 0000 0001 
------------
  1000 0010 = -2
```
#### +0和-0的问题
通过原码的表示规则，我们得到一个+0和一个-0,这个明显不符合数学常识
```
1000 0000 = -0
0000 0000 = +0
```

## 反码
`ones' complement`
反码的出现就是人们为了解决原码不能直接进行计算的问题的。

### 计算规则
原码转反码
* 正数的反码是其本身,(正数的反码和其原码相同)
* 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.


反码转原码
* 先看是不是负数，如果是负数除符号位外按位取反

```
正数
    0000 0001 = 1
负数
    1000 0001[原] = -1
    1111 1110[反] = -1
```
这时候我们再来计算 1 + (-1) 
```
  0000 0001[反] 
+ 1111 1110[反]
------------
  1111 1111[反] = 1000 0000[原] = -0
```
所以反码的出现就解决的原码不能参与计算的问题。
但是+0和-0的问题还是没有解决。

## 补码
补码又叫做  `Two's Complement`
补码就是上面的问题的解决方式。
### 计算规则
* 正数的补码还是其本身,(正数的反码和其原码相同)
* 负数的补码:负数的补码则是将其对应正数按位取反再加1。或者说是负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

```
0000 0001[原] =  0000 0001[补] = 1
1000 0001[原] =  1111 1111[补] = -1

计算过程
1. 对应的正数按位取反
1000 0001 (对应的正数)-> 0000 0001 (取反)-> 1111 1110 (加1)-> 1111 1111

```

### 补码解决运算问题
我们再来进行上面提到的 1 + (-1) 的操作,这次使用补码来计算
```
  0000 0001
+ 1111 1111
------------
 10000 0000
```
我们看到结果得到是一个9位的二进制数，但是因为我们都是8位二进制数，所以在获取结果的时候会取低位的8位，忽略掉最高位的1，这样得到的结果就是 0000 0000，对应的就是0.

### 负数的表示问题
十进制的数据符号有`1、2、3、4、5、6、7、8、9`,二进制有`0、1`，我们加入一个`-`负号对于人来说是很理所当然的事情，但是对于计算机来说并不是。
简单来说就是
* 一个数 减去一个负数，实际上应该是加上应该是加上这个数的真值(去掉了符号的值)。
* 一个数 加上一个负数，实际上应该是减去这个数的真值

这样的运算规则，会使得计算机运算电路的设计变得复杂很多。
所以最好的办法就是让计算机不要理会符号位，然后把减法转化为等价的加法；

所以在这里就可以利用到补数可以把减法转化为加法的特性来解决上面的问题。

**重点来了**
拿8位二进制来说明，8位二进制可以表示 0-255共256个数字。
既然我们想要忽略掉符号位，那么就需要把这256个数字中的一部分，用来表示负数，而且要求是在计算的时候不能影响计算的正确性。



